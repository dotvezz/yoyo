// Generated by github.com/yoyo-project/yoyo

package {{ .PackageName }}

import (
	"database/sql"
	"fmt"

	"{{ .QueryImportPath }}"
)

const (
	insert{{ .ExportedGoName }} = "INSERT INTO {{ .Table.Name }}" +
		" ({{ join ", " .InsertColumns }}) " +
		" VALUES ({{ join ", " .StatementPlaceholders }});"
	update{{ .ExportedGoName }} = "UPDATE {{ .Table.Name }}" +
		" SET {{ join ", " .ColumnAssignments }} %s;"
	select{{ .ExportedGoName }} = "SELECT {{ join ", " .SelectColumns }} FROM {{ .Table.Name }} %s;"
	delete{{ .ExportedGoName }} = "DELETE FROM {{ .Table.Name }} %s;"
)

type {{ .ExportedGoName }}Repository struct {
	*repository
}

func (r *{{ .ExportedGoName }}Repository) FetchOne(query {{ .QueryPackageName }}.Query) (ent {{ .ExportedGoName }}, err error) {
	var stmt *sql.Stmt
	// ensure the *sql.Stmt is closed after we're done with it
	defer func() {
		if stmt != nil && r.tx == nil {
			_ = stmt.Close()
		}
	}()

	conditions, args := query.SQL()
	stmt, err = r.prepare(fmt.Sprintf(select{{ .ExportedGoName }}, conditions))
	if err != nil {
		return
	}

	row := stmt.QueryRow(args...)

	err = row.Scan({{ join ", " .ScanFields }})

	persisted := ent
	ent.persisted = &persisted

	return ent, err
}

func (r *{{ .ExportedGoName }}Repository) Search(query {{ .QueryPackageName }}.Query) (es {{ .ExportedGoName }}s, err error) {
	var stmt *sql.Stmt
	// ensure the *sql.Stmt is closed after we're done with it
	defer func() {
		if stmt != nil && r.tx == nil {
			_ = stmt.Close()
		}
	}()

	conditions, args := query.SQL()
	stmt, err = r.prepare(fmt.Sprintf(select{{ .ExportedGoName }}, conditions))
	if err != nil {
		return es, err
	}

	// If we're in a transaction, take the full result set into memory to free up the sql connection's buffer
	if r.tx != nil {
		var rs *sql.Rows
		rs, err = stmt.Query(args...)
		if err != nil {
			return es, err
		}

		for rs.Next() {
			var ent {{ .ExportedGoName }}
			err = rs.Scan({{ join ", " .ScanFields }})
			if err != nil {
				return es, err
			}
			es.es = append(es.es, ent)
		}

		es.i = -1

		return es, nil
	}

	es.rs, err = stmt.Query(args...)

	return es, err
}
{{ if .PKNames }}
func (r *{{ .ExportedGoName }}Repository) Save(in {{ .ExportedGoName }}) ({{ .ExportedGoName }}, error) {
	if in.persisted == nil {
		return r.insert(in)
	} else {
		return r.update(in)
	}
}

func (r *{{ .ExportedGoName }}Repository) insert(in {{ .ExportedGoName }}) (e {{ .ExportedGoName }}, err error) {
	var (
		stmt *sql.Stmt
		res  sql.Result
	)
	// ensure the *sql.Stmt is closed after we're done with it
	defer func() {
		if stmt != nil && r.tx == nil {
			_ = stmt.Close()
		}
	}()

	stmt, err = r.prepare(insert{{ .ExportedGoName }})
	if err != nil {
		return e, err
	}

	res, err = stmt.Exec({{ join ", " .InFields }})
	if err != nil {
		return e, err
	}
{{ .PKCapture }}
	in = e
	e.persisted = &in

	return e, err
}

func (r *{{ .ExportedGoName }}Repository) update(in {{ .ExportedGoName }}) (e {{ .ExportedGoName }}, err error) {
	var (
		stmt *sql.Stmt
	)
	// ensure the *sql.Stmt is closed after we're done with it
	defer func() {
		if stmt != nil && r.tx == nil {
			_ = stmt.Close()
		}
	}()
{{ .PKQuery }}
	stmt, err = r.prepare(fmt.Sprintf(update{{ .ExportedGoName }}, q))
	if err != nil {
		return e, err
	}

	fields := []interface{}{{ "{" }}{{ join ", " .InFields }}}
	_, err = stmt.Exec(append(fields, args...)...)
	if err != nil {
		return e, err
	}

	e = in
	in = e
	e.persisted = &in

	return e, err
}

func (r *{{ .ExportedGoName }}Repository) Delete(query {{ .QueryPackageName }}.Query) (err error) {
	var stmt *sql.Stmt
	// ensure the *sql.Stmt is closed after we're done with it
	defer func() {
		if stmt != nil && r.tx == nil {
			_ = stmt.Close()
		}
	}()

	conditions, args := query.SQL()
	stmt, err = r.prepare(fmt.Sprintf(delete{{ .ExportedGoName }}, conditions))
	if err != nil {
		return err
	}

	_, err = stmt.Exec(args...)

	return err
}
{{ else }}
func (r *{{ .ExportedGoName }}Repository) Save(in {{ .ExportedGoName }}) (e {{ .ExportedGoName }}, err error) {
	var (
		stmt *sql.Stmt
	)
	// ensure the *sql.Stmt is closed after we're done with it
	defer func() {
		if stmt != nil && r.tx == nil {
			_ = stmt.Close()
		}
	}()

	stmt, err = r.prepare(insert{{ .ExportedGoName }})
	if err != nil {
		return e, err
	}

	_, err = stmt.Exec({{ join ", " .InFields }})
	if err != nil {
		return e, err
	}
{{ .PKCapture }}
	in = e
	e.persisted = &in

	return e, err
}
{{ end }}