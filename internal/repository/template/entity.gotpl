// Generated by github.com/yoyo-project/yoyo

package {{ .PackageName }}

import (
	"database/sql"
	"fmt"
	{{ range .Imports }}
	{{.}}{{end}}
)

type {{ .EntityName }} struct { {{ range .EntityFields }}
	{{.}}{{ end }}{{ if .ReferenceFields }}

	// Reference Fields{{ range .ReferenceFields }}
	{{ . }}
{{ end }}{{ end }}
	// For tracking persistence
	persisted *{{ .EntityName }}
}

// HasChanged is intended to help understand if the entity's current values are represented in the database.
// A few examples are provided below:
//   - For a {{ .EntityName }} which was created outside of a {{ .EntityName }}Repository, HasChanged will return false
//     even if it was used as the input for {{ .EntityName }}Repository.Save.
//   - For an {{ .EntityName }} returned from {{ .EntityName }}Repository.Save, HasChanged will return true. However,
//     changing the value of any field on that {{ .EntityName }} will cause its value to diverge from the last-known
//     persisted value. In that case, its HasChanged method will return false.
//
// The method only tracks changes made to the {{ .EntityName }}, and does NOT track changes on the database itself.
func (e *{{ .EntityName }}) HasChanged() bool {
	return {{ if not .Fields }}false; // there are no fields to change, so it cannot ever change.{{ else }}e.persisted != nil{{ range $i, $f := .Fields }} &&
		{{ if $f.IsSlice }}equal(e.{{ $f.Name }}, e.persisted.{{$f.Name}}){{ else }}e.{{ $f.Name }} == e.persisted.{{$f.Name}}{{ end }}{{ end }}{{ end }}
}

func (e *{{ .EntityName }}) CopyValuesFrom(input {{ .EntityName }}) {{"{"}}{{ range .Fields }}
    e.{{ .Name }} = input.{{ .Name }}{{end}}
}

type {{ .EntityName }}s struct {
	// If we're not in a transaction, then {{ .EntityName }} saves memory by wrapping a *sql.Rows to scan from the connection
	// buffer on-demand.
	// This uses less application memory but more connections to the DBMS.
	rs *sql.Rows

	// If we are in a transaction, then {{ .EntityName }} reads the entire result set to memory to clear the buffer and allow
	// other queries to run on the goroutine.
	// This uses more application memory but fewer connections to the DBMS.
	i  int
	es []{{ .EntityName }}
}

// Next is intended to feel familiar to the Next method of sql.Rows. In fact, when not in a transaction,
// it uses the sql.Rows Next method internally.
func (es *{{ .EntityName }}s) Next() bool {
	if es.rs != nil {
		// not in a transaction
		return es.rs.Next()
	} else {
		// in a transaction
		es.i++
		return es.i < len(es.es)
	}
}

// Scan is intended to feel familiar to the Scan method of sql.Rows. In fact, when not in a transaction,
// it uses the sql.Rows Scan method internally.
func (es *{{ .EntityName }}s) Scan(e *{{ .EntityName }}) (err error) {
	if e == nil {
		return fmt.Errorf("in {{ .EntityName }}s.Scan: passed a nil entity")
	}

	// scan from the rows if NOT IN a transaction
	if es.rs != nil {
		return es.scan(e)
	}

	// load an entity from memory if IN a transaction
	return es.load(e)
}

// scan wraps the Scan method of sql.Rows, only used when not in a connection to minimize memory usage
func (es *{{ .EntityName }}s) scan(e *{{ .EntityName }}) (err error) {
	err = es.rs.Scan({{ range $i, $f := .Fields }}{{ if $i }}, {{ end }}&e.{{ $f.Name }}{{ end }})
	persisted := *e
	e.persisted = &persisted
	return err
}

// load pulls a result from memory, only used if in a transaction to avoid connection contention
func (es *{{ .EntityName }}s) load(e *{{ .EntityName }}) (err error) {
	if es.i >= len(es.es) || es.i < 0 {
		return fmt.Errorf("in {{ .EntityName }}s.point: out of range")
	}
	*e = es.es[es.i]
	persisted := *e
	e.persisted = &persisted
	return nil
}